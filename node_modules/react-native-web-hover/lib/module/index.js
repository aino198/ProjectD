function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import * as React from 'react';
import { View, Pressable as NativePressable, ScrollView as NativeScrollView, FlatList as NativeFlatList, VirtualizedList as NativeVirtualizedList //@ts-ignore
} from 'react-native-web';
const isServer = typeof process !== 'undefined' && process.release && process.release.name === 'node';
const hoverListener = createHoverListener();
export function Hoverable({
  children,
  ...rest
}) {
  const hostRef = React.useRef(null);
  const [hovered, setHovered] = React.useState(false);
  React.useEffect(() => {
    const hr = hostRef.current;
    hoverListener.add(hr, setHovered);
    return () => {
      hoverListener.remove(hr);
    };
  }, [setHovered, hostRef]);
  return /*#__PURE__*/React.createElement(View, _extends({
    ref: hostRef,
    children: typeof children === 'function' ? children({
      hovered
    }) : children
  }, rest));
}

function PressableWithoutRef({
  style,
  children,
  ...rest
}, forwardedRef) {
  const hostRef = React.useRef(null);
  const [hovered, setHovered] = React.useState(false);
  const setRef = setAndForwardRef({
    getForwardedRef: () => forwardedRef,
    setLocalRef: hostNode => {
      hostRef.current = hostNode;
    }
  });
  React.useEffect(() => {
    const hr = hostRef.current;
    hoverListener.add(hr, setHovered);
    return () => {
      hoverListener.remove(hr);
    };
  }, [setHovered, hostRef]);
  return /*#__PURE__*/React.createElement(NativePressable //@ts-ignore
  , _extends({
    ref: setRef,
    style: interactionState => typeof style === 'function' ? style({ ...interactionState,
      hovered
    }) : style,
    children: interactionState => typeof children === 'function' ? children({ ...interactionState,
      hovered
    }) : children
  }, rest));
}

function containsEvent(parent, clickTarget) {
  if (parent === clickTarget) {
    return true;
  }

  if (!parent) {
    return false;
  }

  for (let child of parent.childNodes) {
    if (containsEvent(child, clickTarget)) {
      return true;
    }
  }

  return false;
}

function createHoverListener() {
  let hasMouse = isServer ? false : window.matchMedia('(pointer:fine)').matches;
  let refs = new Map();
  let previousHoverFunc;
  let mousePosition = {
    x: 0,
    y: 0
  };

  function hover(target) {
    // hover is targeted directly
    let hoverFunc = refs.get(target); // let's try to see if any of the children of the hover event are hovered

    if (!hoverFunc) {
      for (let r of refs.keys()) {
        if (containsEvent(r, target)) {
          hoverFunc = refs.get(r);
        }
      }
    }

    previousHoverFunc && previousHoverFunc(false);
    hoverFunc && hoverFunc(true); // cache the previous hover so we can un-hover this later on

    previousHoverFunc = hoverFunc;
  }

  function hoverEvent(event) {
    hover(event.target);
  }

  function unhover() {
    previousHoverFunc && previousHoverFunc(false);
  }

  function captureMousePosition(event) {
    mousePosition.x = event.pageX;
    mousePosition.y = event.pageY;
  } // touch devices have a bug where the onMouseOver is handled while it should not
  // if the user would click something it keeps hovered while it should unhover
  // so only listen to these events if the device has a mouse


  if (hasMouse) {
    document.onmouseover = hoverEvent;
    document.onmousemove = captureMousePosition;
    document.ontouchstart = unhover;
    document.ontouchend = unhover;
    document.ontouchcancel = unhover;
    document.ontouchmove = unhover;
  }

  function add(ref, setHovered) {
    refs.set(ref, setHovered);
  }

  function remove(ref) {
    refs.delete(ref);
  }

  return {
    add,
    remove,
    mousePosition,
    hover
  };
}

function setAndForwardRef({
  getForwardedRef,
  setLocalRef
}) {
  return function forwardRef(ref) {
    const forwardedRef = getForwardedRef();
    setLocalRef(ref); // Forward to user ref prop (if one has been specified)

    if (typeof forwardedRef === 'function') {
      // Handle function-based refs. String-based refs are handled as functions.
      forwardedRef(ref);
    } else if (typeof forwardedRef === 'object' && forwardedRef != null) {
      // Handle createRef-based refs
      forwardedRef.current = ref;
    }
  };
}

function enhanceScrollView(WrappedComponent) {
  const EnhancedScrollView = ({
    forwardedRef,
    onScroll,
    scrollEventThrottle,
    ...rest
  }) => {
    const onScrollInner = e => {
      onScroll && onScroll(e);
      const {
        mousePosition,
        hover
      } = hoverListener;
      hover(document.elementFromPoint(mousePosition.x, mousePosition.y));
    };

    return /*#__PURE__*/React.createElement(WrappedComponent, _extends({
      ref: forwardedRef,
      onScroll: onScrollInner,
      scrollEventThrottle: scrollEventThrottle || 25
    }, rest));
  };

  return /*#__PURE__*/React.forwardRef((props, ref) => {
    return /*#__PURE__*/React.createElement(EnhancedScrollView, _extends({}, props, {
      forwardedRef: ref
    }));
  });
}

export const Pressable = /*#__PURE__*/React.forwardRef(PressableWithoutRef);
export const ScrollView = enhanceScrollView(NativeScrollView);
export const FlatList = enhanceScrollView(NativeFlatList);
export const VirtualizedList = enhanceScrollView(NativeVirtualizedList);
//# sourceMappingURL=index.js.map